
syntax = "proto2";
package org.jetbrains.kotlin.metadata;

//import "org/jetbrains/kotlin/backend/konan/serialization/metadata.proto1";
option java_outer_classname = "KonanIr";
option optimize_for = LITE_RUNTIME;

/*
// This is subject to change.
// One can think of it as a 'descriptor reference'.
// The real descriptor data is encoded in KonanLinkdData.
message KotlinDescriptor {
    enum Kind {
        FUNCTION = 1;
        VARIABLE = 2;
        CLASS = 3;
        VALUE_PARAMETER = 4;
        CONSTRUCTOR = 5;
        TYPE_PARAMETER = 6;
        RECEIVER = 7;
        ACCESSOR = 8;
        PROPERTY = 9;
    }
    // TODO: Use the string table index.
    optional string name = 1;
    required Kind kind = 2;
    required UniqId uniq_id = 3;
    required UniqId original_uniq_id = 4;
    // index in fq name table
    optional int32 class_or_package = 5;

    // Descriptor kind specific fields.
    // TODO: consider introducing specific messages
    // for functions, variables etc.
    optional KotlinType type = 6;
    repeated KotlinDescriptor value_parameter = 7;
    repeated KotlinDescriptor type_parameter = 8;
    optional UniqId dispatch_receiver_uniq_id = 9;
    optional UniqId extension_receiver_uniq_id = 10;
    optional KotlinType extension_receiver_type = 11;
    optional LocalDeclaration ir_local_declaration = 12;
}
*/

message DescriptorReference {
    required string package_fq_name = 1;
    required string class_fq_name = 2;
    required UniqId uniq_id = 3;
    required string name = 9;

    optional bool is_getter = 4 [default=false];
    optional bool is_setter = 5 [default=false];
    optional bool is_fake_override = 6 [default=false];
    optional bool is_default_constructor = 7 [default=false];
    optional bool is_enum_entry = 8 [default=false];
    optional bool is_enum_special = 10 [default=false];
}

message UniqId {
    required int64 index = 1;
}
/*
// Inner descriptors used for inlining.
message DeclarationDescriptor {
    // These are ProtoBuf.Function, ProtoBuf.Class etc
    oneof descriptor {
        Function function = 1;
        Class clazz = 2;
        Property property = 3;
        Constructor constructor = 4;
    }
}

message LocalDeclaration {
    required DeclarationDescriptor descriptor = 1;
}
*/
/*
message KotlinType {
    required int32 index = 1;
    required bool isCaptured = 2; // TODO: make it a flag set?
    optional string debug_text = 3; // TODO: remove me
}
*/

message KotlinType {

}

message Coordinates {
    required int32 start_offset = 1;
    required int32 end_offset = 2;
}

message TypeArguments {
    repeated IrType type_argument = 1;
}

/* ------ Top Level---------------------------------------------- */

message IrDeclarationContainer {
    repeated IrDeclaration declaration = 1;
}

message FileEntry { // TODO: extend me.
    required string name = 1;
}

message IrFile {
    //required IrDeclarationContainer declaration_container = 1;
    repeated UniqId declaration_id = 1;
    required FileEntry file_entry = 2;
    // TODO: we need a better string management. See metadata serialization as an example.
    required string fq_name = 3;
}

message IrModule {
    required string name = 1;
    repeated IrFile file = 2;
}

/* ------ IrSymbols --------------------------------------------- */

enum IrSymbolKind {
    FUNCTION_SYMBOL = 1;
    CONSTRUCTOR_SYMBOL = 2;
    ENUM_ENTRY_SYMBOL = 3;
    FIELD_SYMBOL = 4;
    VALUE_PARAMETER_SYMBOL = 5;
    RETURN_TARGET_SYMBOL = 6;
    CLASS_SYMBOL = 7;
    TYPE_PARAMETER_SYMBOL = 8;
    VARIABLE_SYMBOL = 9;
    ANONYMOUS_INIT_SYMBOL = 10;
}

message IrSymbol {
    required IrSymbolKind kind = 1;
    required UniqId uniq_id = 2;
    optional string fqname = 3;
    optional DescriptorReference descriptor_reference = 4;
}

/* ------ IrTypes --------------------------------------------- */

enum IrTypeVariance { // Should we import metadata variance, or better stay separate?
    IN = 0;
    OUT = 1;
    INV = 2;
}

message Annotations {
    repeated IrCall annotation = 2;
}

message IrTypeBase {
    optional KotlinType kotlin_type = 1;
    required Annotations annotations = 2;
    required IrTypeVariance variance = 3 [default = INV];
}

message IrStarProjection {
    optional bool void = 1;
}

message IrTypeProjection {
    required IrTypeVariance variance = 1;
    required IrType type = 2;
}

message IrTypeArgument {
    oneof kind {
        IrStarProjection star = 1;
        IrTypeProjection type = 2;
    }
}

message IrSimpleType {
    required IrTypeBase base = 1;
    required IrSymbol classifier = 2;
    required bool has_question_mark = 3;
    repeated IrTypeArgument argument = 4;
}

message IrDynamicType {
    required IrTypeBase base = 1;
}

message IrErrorType {
    required IrTypeBase base = 1;
}

message IrType {
    oneof kind {
        IrSimpleType simple = 1;
        IrDynamicType dynamic = 2;
        IrErrorType error = 3;
    }
}

/* ------ IrExpressions --------------------------------------------- */

message IrBreak {
    required int32 loop_id = 1;
    optional string label = 2;
}

message IrBlock {
    required bool is_lambda_origin = 1;
    repeated IrStatement statement = 2; 
}

message MemberAccessCommon {
    optional IrExpression dispatch_receiver = 5;
    optional IrExpression extension_receiver = 6;
    repeated NullableIrExpression value_argument = 8;
    required TypeArguments type_arguments = 9;
}

message IrCall {
    enum Primitive {
        NOT_PRIMITIVE = 1;
        NULLARY = 2;
        UNARY = 3;
        BINARY = 4;
    }
    required Primitive kind = 1;
    required IrSymbol symbol = 2;
    required MemberAccessCommon member_access = 3;
    optional IrSymbol super = 4;
}

message IrFunctionReference {
    required IrSymbol symbol = 1;
    required TypeArguments type_arguments = 2;
    optional string origin = 3;
}


message IrPropertyReference {
   // required UniqId declaration = 1;
    required TypeArguments type_arguments = 2;
    optional IrSymbol field = 3;
    optional IrSymbol getter = 4;
    optional IrSymbol setter = 5;
    optional string origin = 6;
}

message IrComposite {
    repeated IrStatement statement = 1;
}

message IrClassReference {
    required IrSymbol class_symbol = 1;
    required IrType type = 2;
}

message IrConst {
    oneof value {
        bool    null = 1;
        bool    boolean = 2;
        int32   char = 3;
        int32   byte = 4;
        int32   short = 5;
        int32   int = 6;
        int64   long = 7;
        float   float = 8;
        double  double = 9;
        string  string = 10;
    }
}

message IrContinue {
    required int32 loop_id = 1;
    optional string label = 2;
}

message IrDelegatingConstructorCall {
    required IrSymbol symbol = 1;
    required MemberAccessCommon member_access = 2;
}

message IrDoWhile {
    required Loop loop = 1;
}

message IrEnumConstructorCall {
    required IrSymbol symbol = 1;
    required MemberAccessCommon member_access = 2;
}

message IrGetClass {
    required IrExpression argument = 1;
}

message IrGetEnumValue {
    required IrType type = 1;
    required IrSymbol symbol = 2;
}

message FieldAccessCommon {
    required IrSymbol symbol = 1;
    optional IrSymbol super = 2;
    optional IrExpression receiver = 3;
}

message IrGetField {
    required FieldAccessCommon field_access = 1;
    required IrType type = 2;
}

message IrGetValue {
    required IrSymbol symbol = 1;
    required IrType type = 2;
}

message IrGetObject {
    required IrSymbol symbol = 1;
}

message IrInstanceInitializerCall {
    required IrSymbol symbol = 1;
}

message Loop {
    required int32 loop_id = 1;
    required IrExpression condition = 2;
    optional string label = 3;
    optional IrExpression body = 4;
}

message IrReturn {
    required IrSymbol return_target = 1;
    required IrExpression value = 2;
}

message IrSetField {
    required FieldAccessCommon field_access = 1;
    required IrExpression value = 2;
}

message IrSetVariable {
    required IrSymbol symbol = 1;
    required IrExpression value = 2;
}

message IrSpreadElement {
    required IrExpression expression = 1;
    required Coordinates coordinates = 2;
}

message IrStringConcat {
    repeated IrExpression argument = 1; 
}

message IrThrow {
    required IrExpression value = 1;
}

message IrTry {
    required IrExpression result = 1;
    repeated IrStatement catch = 2;
    optional IrExpression finally = 3;
}

message IrTypeOp {
    required IrTypeOperator operator = 1;
    required IrType operand = 2;
    required IrExpression argument = 3;
}

message IrVararg {
    required IrType element_type = 1;
    repeated IrVarargElement element = 2;
}

message IrVarargElement {
    oneof vararg_element {
        IrExpression expression = 1;
        IrSpreadElement spread_element = 2;
    }
}

message IrWhen {
    repeated IrStatement branch = 1;
}

message IrWhile {
    required Loop loop = 1;
}

// TODO: we need an extension mechanism to accomodate new 
// IR operators in upcoming releases.
message IrOperation {
    oneof operation {
        IrBlock block = 1;
        IrBreak break = 2;
        IrCall call = 3;
        IrClassReference class_reference = 27;
        IrConst const = 5;
        IrComposite composite = 26;
        IrContinue continue = 6;
        IrDelegatingConstructorCall delegating_constructor_call = 7;
        IrDoWhile do_while = 25;
        IrEnumConstructorCall enum_constructor_call = 8;
        IrFunctionReference function_reference = 4;
        IrGetClass get_class = 24;
        IrGetEnumValue get_enum_value = 9;
        IrGetField get_field = 10;
        IrGetValue get_value = 11;
        IrGetObject get_object = 12;
        IrInstanceInitializerCall instance_initializer_call = 13;
        IrPropertyReference property_reference = 28;
        IrReturn return = 14;
        IrSetField set_field = 15;
        IrSetVariable set_variable = 16;
        IrStringConcat string_concat = 17;
        //IrSyntheticBody synthetic_body = 28;
        IrThrow throw = 18;
        IrTry try = 19;
        IrTypeOp type_op = 20;
        IrVararg vararg = 21;
        IrWhen when = 22;
        IrWhile while = 23;
    }
}

enum IrTypeOperator {
    CAST = 1;
    IMPLICIT_CAST = 2;
    IMPLICIT_NOTNULL = 3;
    IMPLICIT_COERCION_TO_UNIT = 4;
    IMPLICIT_INTEGER_COERCION = 5;
    SAFE_CAST = 6;
    INSTANCEOF = 7;
    NOT_INSTANCEOF = 8;
}

message IrExpression {
    required IrOperation operation = 1;
    required IrType type = 2;
    required Coordinates coordinates = 3;
}

message NullableIrExpression {
    optional IrExpression expression = 1;
}


/* ------ Declarations --------------------------------------------- */

message IrTypeAlias {
    // Nothing for now.
}

message IrFunction {
    required IrSymbol symbol = 1;
    required IrFunctionBase base = 2;
    required ModalityKind modality = 3;
    required bool is_tailrec = 4;
    required bool is_suspend = 5;
    repeated IrSymbol overridden = 6;
    optional UniqId corresponding_property = 7;

}

message IrFunctionBase {
    required string name = 1;
    required string visibility = 4;
    required bool is_inline = 5;
    required bool is_external = 6;
    required IrTypeParameterContainer type_parameters = 7;
    optional IrValueParameter dispatch_receiver = 8;
    optional IrValueParameter extension_receiver = 9;
    repeated IrValueParameter value_parameter = 10;
    optional IrStatement body = 12;
    required IrType return_type = 11;
}

message IrConstructor {
    required IrSymbol symbol = 3;
    required IrFunctionBase base = 1;
    required bool is_primary = 2;

}

message IrField {
    required IrSymbol symbol = 1;
    optional IrExpression initializer = 2;
    required string name = 3;
    required string visibility = 4;
    required bool is_final = 5;
    required bool is_external = 6;
    required bool is_static = 7;
    required IrType type = 8;
    }

message IrProperty {
    required UniqId declaration = 1; // IrProperty doesn't have a symbol at all. Preserve this rudiment for now.
    required string name = 10;
    required string visibility = 11;
    required ModalityKind modality = 12;
    required bool is_var = 13;
    required bool is_const = 14;
    required bool is_lateinit = 15;
    required bool is_delegated = 16;
    required bool is_external = 17;
    optional IrField backing_field = 2;
    optional IrFunction getter = 3;
    optional IrFunction setter = 4;
}

message IrVariable {
    required string name = 1;
    required IrSymbol symbol = 7;
    required IrType type = 2;
    required bool is_var = 3;
    required bool is_const = 4;
    required bool is_lateinit = 5;
    optional IrExpression initializer = 6;
}

enum ClassKind {
    CLASS = 1;
    INTERFACE = 2;
    ENUM_CLASS = 3;
    ENUM_ENTRY = 4;
    ANNOTATION_CLASS = 5;
    OBJECT = 6;
}

enum ModalityKind { // It is ModalityKind to not clash with Modality in descriptor metadata.
    FINAL_MODALITY = 1;
    SEALED_MODALITY = 2;
    OPEN_MODALITY = 3;
    ABSTRACT_MODALITY = 4;
}

message IrValueParameter {
    required IrSymbol symbol = 1;
    required string name = 2;
    required int32 index = 3;
    required IrType type = 4;
    optional IrType vararg_element_type = 5;
    required bool is_crossinline = 6;
    required bool is_noinline = 7;
    optional IrExpression default_value = 8;
}

message IrTypeParameter {
    required IrSymbol symbol = 1;
    required string name = 2;
    required int32 index = 3;
    required IrTypeVariance variance = 4;
    repeated IrType super_type = 5;
}

message IrTypeParameterContainer {
    repeated IrTypeParameter type_parameter = 1;
}

message IrClass {
    required IrSymbol symbol = 1;
    required string name = 2;
    required ClassKind kind = 3;
    required string visibility = 4;
    required ModalityKind modality = 5;
    // TODO: consider using flags for the booleans.
    required bool is_companion = 6;
    required bool is_inner = 7;
    required bool is_data = 8;
    required bool is_external = 9;
    required bool is_inline = 14;
    optional IrValueParameter this_receiver = 10;
    required IrTypeParameterContainer type_parameters = 11;
    required IrDeclarationContainer declaration_container = 12;
    repeated IrType super_type = 13;
}

message IrEnumEntry {
    required IrSymbol symbol = 4;
    optional IrExpression initializer = 1;
    optional IrDeclaration corresponding_class = 2;
    required string name = 3;
}

message IrAnonymousInit {
    required IrSymbol symbol = 2;
    required IrStatement body = 1;
}

// TODO: we need an extension mechanism to accomodate new 
// IR operators in upcoming releases.
message IrDeclarator {
    oneof declarator {
        IrAnonymousInit ir_anonymous_init = 7;
        IrVariable ir_variable = 1;
        IrField ir_field = 8;
        IrFunction ir_function = 2;
        IrClass ir_class = 3;
        IrEnumEntry ir_enum_entry = 4;
        IrProperty ir_property = 5;
        IrConstructor ir_constructor = 6;
        IrTypeAlias ir_type_alias = 9;
    }
}

message IrDeclarationOrigin {
    required string name = 1;
}

message IrDeclaration {
    //required KotlinDescriptor descriptor = 1;
    //required UniqId uniqId = 1;
    required IrDeclarationOrigin origin = 1;
    required Coordinates coordinates = 2;
    required Annotations annotations = 6;
    required IrDeclarator declarator = 3;
    repeated IrDeclaration nested = 4;
    required string file_name = 5;
}

/* ------- IrStatements --------------------------------------------- */

message IrBranch {
    required IrExpression condition = 1;
    required IrExpression result = 2;
}

message IrBlockBody {
    repeated IrStatement statement = 1;
}

message IrCatch {
    required IrDeclaration catch_parameter = 1;
    required IrExpression result = 2;
}

enum IrSyntheticBodyKind {
    ENUM_VALUES = 1;
    ENUM_VALUEOF = 2;
}

message IrSyntheticBody {
    required IrSyntheticBodyKind kind = 1;
}

// Let's try to map IrElement as well as IrStatement to IrStatement.
message IrStatement {
    required Coordinates coordinates = 1;
    oneof statement {
        IrDeclaration declaration = 2;
        IrExpression expression = 3;
        IrBlockBody block_body = 4;
        IrBranch branch = 5;
        IrCatch catch = 6;
        IrSyntheticBody synthetic_body = 7;
    }
}

